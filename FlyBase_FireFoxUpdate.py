# Generated by Selenium IDE
import time
import shutil
import csv


from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.proxy import *
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.firefox_profile import FirefoxProfile
class Web_Interface():
  def setup_method(self, tissue, outpath, writable_annotation):

    self.tissue = tissue
    self.filename = writable_annotation
    #ensures correct structure of flybase output
    self.outpath = f"{outpath}/Downloaded_lists"

    defined_options = Options()
    
    defined_options.headless = True
    defined_options.set_preference("browser.download.manager.showWhenStarting", False)
    defined_options.set_preference("browser.download.dir",self.outpath)
    defined_options.set_preference("browser.helperApps.neverAsk.saveToDisk", "application/octet-stream doc xls pdf txt")
    defined_options.set_preference("browser.download.folderList", 2)
    defined_options.set_preference("browser.download.downloadDir", self.outpath)
    defined_options.set_preference("browser.download.defaultFolder", self.outpath)
    defined_options.set_preference("browser.download.useDownloadDir", True)

       
    polipo_proxy = "http://wwwcache.gla.ac.uk:8080"
    proxy = Proxy({
        'proxyType': ProxyType.MANUAL,
        'httpProxy': polipo_proxy,
        'httpsProxy':polipo_proxy,
        'ftpProxy' : polipo_proxy,
        'sslProxy' : polipo_proxy,
        'noProxy'  : ''
    })
    desired_capabilities = dict(DesiredCapabilities.FIREFOX)
    proxy.add_to_capabilities(desired_capabilities)
    desired_capabilities['acceptInsecureCerts'] = True         
    desired_capabilities['acceptSslCerts'] = True


    self.driver = webdriver.Firefox(options = defined_options, desired_capabilities=desired_capabilities, proxy=proxy)

    self.vars = {}
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def wait_for_window(self, timeout = 2):
    time.sleep(round(timeout / 1000))
    wh_now = self.driver.window_handles
    wh_then = self.vars["window_handles"]
    if len(wh_now) > len(wh_then):
      return set(wh_now).difference(set(wh_then)).pop()
  
  def find_annotated_genes(self):
    errors = [0, 0]

    #navigates to the FlyBase Querybuilder
    self.driver.get("https://flybase.org/cgi-bin/qb.pl")
    
    print('Got to QueryBuilder page')

#    WebDriverWait(self.driver, 30).until(
 #       EC.presence_of_element_located((By.CSS_SELECTOR, "#segment01 > b"))
  #  )
   # self.driver.find_element(By.CSS_SELECTOR, "#segment01 > b").click()

    WebDriverWait(self.driver, 30).until(
            EC.presence_of_element_located((By.ID, "segment01"))
        )
    element = self.driver.find_element(By.ID, "segment01")

    actions = ActionChains(self.driver)
    actions.move_to_element(element).click().perform()
    
    print('New Query Clicked')
    time.sleep(3)
    #Selects the "Controlled Vocabulary" search option
    WebDriverWait(self.driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "td:nth-child(1) > select"))
        )
    
    self.driver.find_element(By.CSS_SELECTOR, "td:nth-child(1) > select").click()
    dropdown = self.driver.find_element(By.CSS_SELECTOR, "td:nth-child(1) > select")
    
    print('Controlled Vocab selected')

    WebDriverWait(self.driver, 30).until(
            EC.presence_of_element_located((By.XPATH, "/html/body/div[4]/form[2]/table[1]/tbody/tr[1]/td[1]/select/option[6]"))
        )
    dropdown.find_element(By.XPATH, "/html/body/div[4]/form[2]/table[1]/tbody/tr[1]/td[1]/select/option[6]").click()
    time.sleep(3)
    
    #Submits the user-selected Vocab option
    self.driver.find_element(By.CSS_SELECTOR, "select:nth-child(2) > option:nth-child(6)").click()
    self.driver.find_element(By.CSS_SELECTOR, "#segment1 > input").click()
    self.driver.find_element(By.CSS_SELECTOR, "#segment1 > input").send_keys(self.tissue)
    self.driver.find_element(By.CSS_SELECTOR, "#doneediting1 > b").click()
    
    print('Chosen term selected')

    #Begins the search
    time.sleep(30)

    self.driver.get_screenshot_as_file(f"{self.outpath}/FLYBASE_{self.tissue}_screenshot.png")

    WebDriverWait(self.driver, 30).until(
            EC.presence_of_element_located((By.ID, "run"))
        )

    print('RUN button found')

    self.driver.find_element(By.ID, "run").click()

    print('Search Run Successfully')

    self.vars["window_handles"] = self.driver.window_handles
    
    #Handles the "genes" page, navigating there and downloading all genes associated with the vocab term
    try:
      print('Handling Genes')

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.ID, "alt-fbgn"))
      )
      
      self.driver.find_element(By.ID, "alt-fbgn").click()

      self.vars["win6583"] = self.wait_for_window(2000)
      self.vars["root"] = self.driver.current_window_handle
      self.driver.switch_to.window(self.vars["win6583"])

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.ID, "hitlist-export"))
      )
      self.driver.find_element(By.ID, "hitlist-export").click()
      self.driver.find_element(By.LINK_TEXT, "Batch Download").click(),

      time.sleep(5)

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "#ids"))
      )

      id_area = self.driver.find_element(By.CSS_SELECTOR, "#ids")
      copied_text = id_area.get_attribute('value')

      with open(f'{self.outpath}/{self.filename}_AnyAnnotations.txt', 'w+') as geneout:
        geneout.write(copied_text)

      #returns back to the search results
      self.driver.close()
      self.driver.switch_to.window(self.vars["root"])
      self.driver.find_element(By.NAME, "hiddenmain").click()
      self.vars["window_handles"] = self.driver.window_handles
    
    #If the "Genes" button can't be found, we check whether this is a Selenium error of a genuine lack of genes associated with the term.
    except Exception as e:
     
      self.driver.get_screenshot_as_file(f"{self.outpath}/FLYBASE_ERROR_screenshot.png")
      try:
                
        #test_point = self.driver.find_element(By.CSS_SELECTOR, "#wrapper_two > table:nth-child(4) > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(1) > b:nth-child(1)")

        print(f'No genes associated with tissue {self.tissue}')

        errors[0] = 1
            
      except Exception as e:

        print(e)
        raise LookupError


    #Handles the "Alleles" page, navigating there and downloading all genes associated with the vocab term
    try:
      print('Handling Alleles')

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.ID, "alt-fbal"))
      )

      self.driver.find_element(By.ID, "alt-fbal").click()

      self.vars["win8463"] = self.wait_for_window(2000)
      self.driver.switch_to.window(self.vars["win8463"])

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.ID, "hitlist-export"))
      )
      element = self.driver.find_element(By.ID, "hitlist-export").click()
      self.driver.find_element(By.LINK_TEXT, "Batch Download").click()

      time.sleep(5)

      WebDriverWait(self.driver, 30).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "#ids"))
      )

      id_area = self.driver.find_element(By.CSS_SELECTOR, "#ids")
      copied_text = id_area.get_attribute('value')

      with open(f'{self.outpath}/{self.filename}_AllelesCausingPhenotypes.txt', 'w+') as geneout:
        geneout.write(copied_text)

      #Exits windows
      self.driver.close()
      self.driver.switch_to.window(self.vars["root"])

    except Exception as e:
      
      self.driver.get_screenshot_as_file(f"{self.outpath}/FLYBASE_ERROR_screenshot.png")
      try:
                
        #test_point = self.driver.find_element(By.CSS_SELECTOR, "#wrapper_two > table:nth-child(4) > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(1) > b:nth-child(1)")

        print(f'No alleles associated with tissue {self.tissue}')

        errors[1] = 1
            
      except Exception as e:

        print(e)
        raise LookupError
      
    self.driver.close()

    return errors

 
  #Creates a list of the desired annotations, from the annotation text file.
def populate_lists(annos):

    annolist = []

    with open(annos) as annofile:
        for line in annofile:
            annolist.append(line.strip('\n'))
    
    return annolist

#Uses the supplied FlyBase Alleles â‡” Genes file to associate each allele found 
def convert_alleles(alleles, allelefile):
    converted = []

    with open(allelefile) as af:
        INallele = csv.reader(af, delimiter = '\t')
        
        next(INallele)
        next(INallele)

        for line in INallele:
            fbal = line[0]
            fbid = line[2]

            if fbal in alleles:
                converted.append(fbid)
    
    return converted

def check_lists(annotation, outpath, fulloutdict, tallyany, tallyphenotype, genelist, allelefile, error_cases, workinganno):

    fulloutdict['Header'].append(f'Any known link to {annotation}?')
    fulloutdict['Header'].append(f'Any allele causing a phenotype in {annotation}?')
    
    time.sleep(5)
    if error_cases[0] == 0:
        print(f'{outpath}/Downloaded_lists/{workinganno}_AnyAnnotations.txt')
        with open(f'{outpath}/Downloaded_lists/{workinganno}_AnyAnnotations.txt') as file1:
            anygenes = file1.readlines()
    else:
        print('cannot open file')
        anygenes = []

    if error_cases[1] == 0:
        print(f'{outpath}/Downloaded_lists/{workinganno}_AllelesCausingPhenotypes.txt')
        with open(f'{outpath}/Downloaded_lists/{workinganno}_AllelesCausingPhenotypes.txt') as file2:
            phenogenes = file2.readlines()
    else:
        print('cannot open file')
        phenogenes = []

    found = []
    alleles = []
    for line in anygenes:
        geneid = line.strip('\n')
        
        if geneid in genelist:
            tallyany[geneid] += 1
            fulloutdict[geneid].append(1)
            found.append(geneid)

    print('checking of "Any Genes" completed')

    for gene in genelist:
        if gene not in found:
            fulloutdict[gene].append(0)
    
    found2 = []
    for line in phenogenes:
        alleleid = line.strip('\n')
        alleles.append(alleleid)
    
    print('Checking of alleles finished')

    convertedgenes = convert_alleles(alleles, allelefile)

    for geneid in convertedgenes:
        if geneid in genelist and geneid not in found2:
            tallyphenotype[geneid] += 1
            fulloutdict[geneid].append(1)
            
            if fulloutdict[geneid][-2] == 0:
                tallyany[geneid] += 1
                fulloutdict[geneid][-2] = 1
            found2.append(geneid)
    
    for gene in genelist:
        if gene not in found2:
            fulloutdict[gene].append(0)

    print('genes with tissue annotation:', len(found))
    print('genes with allele causing phenotype:',len(found2))    

    return fulloutdict, tallyany, tallyphenotype
        
def make_outputs(outfolder, outfoldertally, num_annotations, genelist, fulloutdict, tallyany, tallyphenotype):
    with open(f'{outfolder}/FullAnalysis.csv', 'w+') as fullanalysisfile:
        OUTfull = csv.writer(fullanalysisfile)

        OUTfull.writerow(fulloutdict['Header'])

        for gene in genelist:
            OUTfull.writerow(fulloutdict[gene])
    
    with open(f'{outfoldertally}/FlyBase_tally.csv', 'w+') as tallyoutfile:
        OUTtally = csv.writer(tallyoutfile)

        header = ['Gene ID', 'FlyBase - Score for ANY association with defined tissues', 'Flybase - Score for KNOWN PHENOTYPE in defined tissues']
        OUTtally.writerow(header)

        for gene in genelist:
            outrow = [gene, (tallyany[gene]/num_annotations), (tallyphenotype[gene]/num_annotations)]
            OUTtally.writerow(outrow)

def print_errors(outfolder, error_cases):
    with open(f'{outfolder}/FlyBase_Errors.txt', 'w+') as errfile:
        errfile.write('The following terms could not be queried on FlyBase\n\n')
        for err in error_cases:
            errfile.write(f'{err}\n')

def check_the_literature(input_fbids, target_annotations, outputfb, outputtally, alleles_file):

    annolist = target_annotations
    writable_annotations = {}

    for base_anno in target_annotations:
        i_anno = '' + base_anno

        if '/' in i_anno:
            i_anno = i_anno.replace('/', '_')
        if ' ' in i_anno:
            i_anno = i_anno.replace(' ', '_')

        writable_annotations[base_anno] = i_anno

    print(writable_annotations)

    genelist = populate_lists(input_fbids)

    num_annotations = len(annolist)

    tallyany = {}
    tallyphenotype = {}
    fulloutdict = {}
    errorlist = []

    fulloutdict['Header'] = ['Gene ID', ]

    for gene in genelist:
        tallyany[gene] = 0
        tallyphenotype[gene] = 0
        fulloutdict[gene] = [gene,]

    for annotation in annolist:
        try:
            writable_anno = writable_annotations[annotation]
            print(f'\n{annotation} started')
            SeleniumDriver = Web_Interface()
            SeleniumDriver.setup_method(annotation, outputfb, writable_anno)
            error_cases = SeleniumDriver.find_annotated_genes()

            fulloutdict, tallyany, tallyphenotype = check_lists(annotation, outputfb, fulloutdict, tallyany, tallyphenotype, genelist, alleles_file, error_cases, writable_anno)
            print(f'{annotation} finished')
            time.sleep(5)
        except:
            errorlist.append(annotation)
            num_annotations -= 1
    
    if num_annotations > 0:
        make_outputs(outputfb, outputtally, num_annotations, genelist, fulloutdict, tallyany, tallyphenotype)

    if errorlist != []:
        print_errors(outputfb, errorlist)
    if num_annotations <= 0:
        raise ValueError
